// FieldValidationModelMacro.swift
//
// Copyright 2025 FOS Computer Services, LLC
//
// Licensed under the Apache License, Version 2.0 (the  License);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#if os(macOS) || os(Linux)
public import SwiftSyntax
import SwiftSyntaxBuilder
public import SwiftSyntaxMacros

public enum FieldValidationModelMacroError: Error, CustomDebugStringConvertible {
    case onlyStructs

    public var debugDescription: String {
        switch self {
        case .onlyStructs:
            "FieldValidationModelMacroError: @FieldValidationModel can only be applied to structs"
        }
    }
}

// Example:
//
// @FieldValidationModel
// struct MyFieldValidationModel/* : FieldValidationModel <- No need to add, will be added automatically */ {
//   @LocalizableString public var myStr
//   @LocalizableInt public var myInt = 25
//
//   // This function is generated by the macro
//   public func propertyNames() -> [LocalizableId: String] { [
//      myStr.localizationId: "myStr",
//      myInt.localizationId: "myInt"
//   ] }
// }
//

public struct FieldValidationModelMacro: ExtensionMacro, MemberMacro {
    private static let knownLocalizedPropertyNames = [
        // _LocalizedProperty
        "LocalizedString",
        "LocalizedInt",
        "LocalizedCompoundString",
        "LocalizedSubs",

        // _LocalizedArrayProperty
        "LocalizedStrings"
    ]

    // MARK: Extension Macro Protocol

    public static func expansion(
        of node: AttributeSyntax,
        attachedTo declaration: some DeclGroupSyntax,
        providingExtensionsOf type: some TypeSyntaxProtocol,
        conformingTo protocols: [TypeSyntax],
        in context: some MacroExpansionContext
    ) throws -> [ExtensionDeclSyntax] {
        guard node.attributeName.description.trimmingCharacters(in: .whitespaces) == "FieldValidationModel" else {
            return []
        }

        // Ensure the declaration is a struct
        guard let structDecl = declaration.as(StructDeclSyntax.self) else {
            throw FieldValidationModelMacroError.onlyStructs
        }

        var result = [ExtensionDeclSyntax]()

        // Skip extension generation if FieldValidationModel is explicitly declared
        // Note: Indirect conformances (via other protocols) are not detected due to SwiftSyntax limitations
        if !structDecl.conformsTo("FieldValidationModel") {
            // Create an extension with FieldValidationModel conformance
            let extensionDecl = ExtensionDeclSyntax(
                extendedType: type,
                inheritanceClause: InheritanceClauseSyntax {
                    InheritedTypeSyntax(type: TypeSyntax(stringLiteral: "FieldValidationModel"))
                },
                memberBlock: MemberBlockSyntax(members: [])
            )

            result.append(extensionDecl)
        }

        // Skip extension generation if FieldValidationModel is explicitly declared
        // Note: Indirect conformances (via other protocols) are not detected due to SwiftSyntax limitations
        if !structDecl.conformsTo("RetrievablePropertyNames") {
            // Create an extension with FieldValidationModel conformance
            let extensionDecl = ExtensionDeclSyntax(
                extendedType: type,
                inheritanceClause: InheritanceClauseSyntax {
                    InheritedTypeSyntax(type: TypeSyntax(stringLiteral: "RetrievablePropertyNames"))
                },
                memberBlock: MemberBlockSyntax(members: [])
            )

            result.append(extensionDecl)
        }

        return result
    }

    public static func expansion(
        of node: AttributeSyntax,
        providingMembersOf declaration: some DeclGroupSyntax,
        conformingTo protocols: [TypeSyntax],
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        guard node.attributeName.description.trimmingCharacters(in: .whitespaces) == "FieldValidationModel" else {
            return []
        }

        // Ensure the declaration is a struct
        guard let structDecl = declaration.as(StructDeclSyntax.self) else {
            throw FieldValidationModelMacroError.onlyStructs
        }

        // Collect properties with _LocalizedProperty wrapper
        let properties = structDecl.memberBlock.members.compactMap { member -> (name: String, id: String)? in
            guard let varDecl = member.decl.as(VariableDeclSyntax.self),
                  let binding = varDecl.bindings.first,
                  let identifier = binding.pattern.as(IdentifierPatternSyntax.self)?.identifier.text
            else {
                return nil
            }

            // Check for LocalizableString or LocalizableInt attributes
            let hasLocalizedWrapper = varDecl.attributes.contains { attribute in
                guard let attr = attribute.as(AttributeSyntax.self) else { return false }
                let attrName = attr.attributeName.description.trimmingCharacters(in: .whitespaces)
                return Self.knownLocalizedPropertyNames.contains(attrName)
            }

            guard hasLocalizedWrapper else { return nil }

            return (name: identifier, id: "\(identifier).localizationId")
        }

        var newDecls: [DeclSyntax] = []

        // Generate the propertyNames function
        var pairs = properties.map { "_\($0.id): \"\($0.name)\"" }.joined(separator: ", ")
        if pairs.isEmpty {
            pairs = ":"
        }
        let propertyNamesDecl = try FunctionDeclSyntax(
            """
            public func propertyNames() -> [LocalizableId: String] {
                [\(raw: pairs)]
            }
            """
        )
        newDecls.append(DeclSyntax(propertyNamesDecl))

        return newDecls
    }
}

private extension StructDeclSyntax {
    func conformsTo(_ protocolName: String) -> Bool {
        inheritanceClause?.inheritedTypes.contains { inheritedType in
            if let identifierType = inheritedType.type.as(IdentifierTypeSyntax.self) {
                identifierType.name.text == protocolName
            } else {
                false
            }
        } ?? false
    }

    var initParams: [(name: String, type: String)] {
        let initializers = memberBlock.members.compactMap {
            $0.decl.as(InitializerDeclSyntax.self)
        }
        guard let initializer = initializers.first else {
            return []
        }
        // Extract parameters from initializer
        return initializer.signature.parameterClause.parameters.compactMap { param -> (name: String, type: String)? in
            guard let typeAnnotation = TypeSyntax(param.type)?.description else {
                return nil
            }
            return (name: param.firstName.text, type: typeAnnotation)
        }
    }
}
#endif
