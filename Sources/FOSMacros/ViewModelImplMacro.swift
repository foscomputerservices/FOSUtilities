// ViewModelImplMacro.swift
//
// Created by David Hunt on 4/12/25
// Copyright 2025 FOS Computer Services, LLC
//
// Licensed under the Apache License, Version 2.0 (the  License);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

public import SwiftSyntax
import SwiftSyntaxBuilder
public import SwiftSyntaxMacros

public enum ViewModelMacroError: Error, CustomDebugStringConvertible {
    case onlyStructs

    public var debugDescription: String {
        switch self {
        case .onlyStructs:
            "ViewModelMacroError: @ViewModelImpl can only be applied to structs"
        }
    }
}

// Example:
//
// @ViewModelImpl
// struct MyViewModel: ViewModel {
//   @LocalizableString public var myStr
//   @LocalizableInt public var myInt = 25
//
//   // This function is generated by the macro
//   public func propertyNames() -> [LocalizableId: String] { [
//      myStr.localizationId: "myStr",
//      myInt.localizationId: "myInt"
//   ] }
// }
//

public struct ViewModelImplMacro: ExtensionMacro, MemberMacro {
    private static let knownLocalizedPropertyNames = [
        // _LocalizedProperty
        "LocalizedString",
        "LocalizedInt",
        "LocalizedCompoundString",
        "LocalizedSubs",

        // _LocalizedArrayProperty
        "LocalizedStrings"
    ]

    // MARK: Extension Macro Protocol

    public static func expansion(
        of node: AttributeSyntax,
        attachedTo declaration: some DeclGroupSyntax,
        providingExtensionsOf type: some TypeSyntaxProtocol,
        conformingTo protocols: [TypeSyntax],
        in context: some MacroExpansionContext
    ) throws -> [ExtensionDeclSyntax] {
        // Ensure the declaration is a struct
        guard let structDecl = declaration.as(StructDeclSyntax.self) else {
            throw ViewModelMacroError.onlyStructs
        }

        // I'd love to use 'protocols' here, but it's empty in my tests

        // Don't double declare
        let alreadyConforms = structDecl.inheritanceClause?.inheritedTypes.contains { inheritedType in
            if let identifierType = inheritedType.type.as(IdentifierTypeSyntax.self) {
                identifierType.name.text == "ViewModel"
            } else {
                false
            }
        } ?? false

        // Skip extension generation if ViewModel is explicitly declared
        // Note: Indirect conformances (via other protocols) are not detected due to SwiftSyntax limitations
        if alreadyConforms {
            return []
        }

        // Create an extension with ViewModel conformance
        let extensionDecl = ExtensionDeclSyntax(
            extendedType: type,
            inheritanceClause: InheritanceClauseSyntax {
                InheritedTypeSyntax(type: TypeSyntax(stringLiteral: "ViewModel"))
            },
            memberBlock: MemberBlockSyntax(members: [])
        )

        return [extensionDecl]
    }

    public static func expansion(
        of node: AttributeSyntax,
        providingMembersOf declaration: some DeclGroupSyntax,
        conformingTo protocols: [TypeSyntax],
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        // Ensure the declaration is a struct
        guard let structDecl = declaration.as(StructDeclSyntax.self) else {
            throw ViewModelMacroError.onlyStructs
        }

        // Collect properties with _LocalizedProperty wrapper
        let properties = structDecl.memberBlock.members.compactMap { member -> (name: String, id: String)? in
            guard let varDecl = member.decl.as(VariableDeclSyntax.self),
                  let binding = varDecl.bindings.first,
                  let identifier = binding.pattern.as(IdentifierPatternSyntax.self)?.identifier.text
            else {
                return nil
            }

            // Check for LocalizableString or LocalizableInt attributes
            let hasLocalizedWrapper = varDecl.attributes.contains { attribute in
                guard let attr = attribute.as(AttributeSyntax.self) else { return false }
                let attrName = attr.attributeName.description.trimmingSuffix(" ")
                return Self.knownLocalizedPropertyNames.contains(attrName)
            }

            guard hasLocalizedWrapper else { return nil }

            return (name: identifier, id: "\(identifier).localizationId")
        }

        // Generate the propertyNames function
        var pairs = properties.map { "_\($0.id): \"\($0.name)\"" }.joined(separator: ", ")
        if pairs.isEmpty {
            pairs = ":"
        }
        let functionDecl = try FunctionDeclSyntax(
            """
            public func propertyNames() -> [LocalizableId: String] {
                [\(raw: pairs)]
            }
            """
        )

        return [DeclSyntax(functionDecl)]
    }
}
