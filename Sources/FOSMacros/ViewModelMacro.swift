// ViewModelMacro.swift
//
// Copyright 2025 FOS Computer Services, LLC
//
// Licensed under the Apache License, Version 2.0 (the  License);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

public import SwiftSyntax
import SwiftSyntaxBuilder
public import SwiftSyntaxMacros

public enum ViewModelMacroError: Error, CustomDebugStringConvertible {
    case onlyStructs

    public var debugDescription: String {
        switch self {
        case .onlyStructs:
            "ViewModelMacroError: @ViewModel can only be applied to structs"
        }
    }
}

// Example:
//
// @ViewModel
// struct MyViewModel/* : ViewModel <- No need to add, will be added automatically */ {
//   @LocalizableString public var myStr
//   @LocalizableInt public var myInt = 25
//
//   // This function is generated by the macro
//   public func propertyNames() -> [LocalizableId: String] { [
//      myStr.localizationId: "myStr",
//      myInt.localizationId: "myInt"
//   ] }
// }
//

private enum ViewModelOptions: String {
    /// Generate ``ClientHostedViewModelFactory`` support
    case clientHostedFactory
}

public struct ViewModelMacro: ExtensionMacro, MemberMacro, PeerMacro {
    private static let knownLocalizedPropertyNames = [
        // _LocalizedProperty
        "LocalizedString",
        "LocalizedInt",
        "LocalizedCompoundString",
        "LocalizedSubs",

        // _LocalizedArrayProperty
        "LocalizedStrings"
    ]

    // MARK: Extension Macro Protocol

    public static func expansion(
        of node: AttributeSyntax,
        attachedTo declaration: some DeclGroupSyntax,
        providingExtensionsOf type: some TypeSyntaxProtocol,
        conformingTo protocols: [TypeSyntax],
        in context: some MacroExpansionContext
    ) throws -> [ExtensionDeclSyntax] {
        guard node.attributeName.description.trimmingCharacters(in: .whitespaces) == "ViewModel" else {
            return []
        }

        // Ensure the declaration is a struct
        guard let structDecl = declaration.as(StructDeclSyntax.self) else {
            throw ViewModelMacroError.onlyStructs
        }

        let options: Set<ViewModelOptions> = if let argumentList = node.arguments?.as(LabeledExprListSyntax.self),
                                                let optionsElement = argumentList.first(where: { $0.label?.text == "options" }),
                                                let arrayExpr = optionsElement.expression.as(ArrayExprSyntax.self) {
            Set(arrayExpr.elements.map(\.expression)
                .compactMap { $0.as(MemberAccessExprSyntax.self)?.declName }
                .map(\.baseName.text)
                .compactMap { ViewModelOptions(rawValue: $0) })
        } else {
            []
        }

        let viewModelName = structDecl.name.text

        var result = [ExtensionDeclSyntax]()

        // Skip extension generation if ViewModel is explicitly declared
        // Note: Indirect conformances (via other protocols) are not detected due to SwiftSyntax limitations
        if !structDecl.conformsTo("ViewModel") {
            // Create an extension with ViewModel conformance
            let extensionDecl = ExtensionDeclSyntax(
                extendedType: type,
                inheritanceClause: InheritanceClauseSyntax {
                    InheritedTypeSyntax(type: TypeSyntax(stringLiteral: "ViewModel"))
                },
                memberBlock: MemberBlockSyntax(members: [])
            )

            result.append(extensionDecl)
        }

        if options.contains(.clientHostedFactory) {
            if !structDecl.conformsTo("ClientHostedViewModelFactory") {
                // Find the initializer
                let initializers = structDecl.memberBlock.members.compactMap {
                    $0.decl.as(InitializerDeclSyntax.self)
                }
                if let initializer = initializers.first {
                    // Extract parameters from initializer
                    let parameters = initializer.signature.parameterClause.parameters.compactMap { param -> (name: String, type: String)? in
                        guard let typeAnnotation = TypeSyntax(param.type)?.description else {
                            return nil
                        }
                        return (name: param.firstName.text, type: typeAnnotation)
                    }

                    // Generate AppState struct
                    let appStateProperties = parameters.map { param in
                        "public let \(param.name): \(param.type)"
                    }.joined(separator: "\n")

                    let appStateInitParameters = parameters.map { param in
                        "\(param.name): \(param.type)"
                    }.joined(separator: ", ")

                    let appStateInitAssignments = parameters.map { param in
                        "self.\(param.name) = \(param.name)"
                    }.joined(separator: "\n")

                    // Generate model function
                    let modelInitArgs = parameters.map { param in
                        "\(param.name): context.appState.\(param.name)"
                    }.joined(separator: ", ")

                    let requestableProtoDecl = structDecl.conformsTo("RequestableViewModel")
                        ? ""
                        : ", RequestableViewModel"

                    let extensionDecl = try ExtensionDeclSyntax(
                        """
                        extension \(type): ClientHostedViewModelFactory\(raw: requestableProtoDecl) {
                            public typealias Request = \(raw: viewModelName)Request

                            public struct AppState: Hashable, Sendable {
                                \(raw: appStateProperties)

                                public init(\(raw: appStateInitParameters)) {
                                    \(raw: appStateInitAssignments)
                                }
                            }

                            public static func model(
                                context: ClientHostedModelFactoryContext<Request, AppState>
                            ) async throws -> Self {
                                .init(\(raw: modelInitArgs))
                            }
                        }
                        """
                    )

                    result.append(extensionDecl)
                }
            }
        }

        return result
    }

    public static func expansion(
        of node: AttributeSyntax,
        providingMembersOf declaration: some DeclGroupSyntax,
        conformingTo protocols: [TypeSyntax],
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        guard node.attributeName.description.trimmingCharacters(in: .whitespaces) == "ViewModel" else {
            return []
        }

        // Ensure the declaration is a struct
        guard let structDecl = declaration.as(StructDeclSyntax.self) else {
            throw ViewModelMacroError.onlyStructs
        }

        // Collect properties with _LocalizedProperty wrapper
        let properties = structDecl.memberBlock.members.compactMap { member -> (name: String, id: String)? in
            guard let varDecl = member.decl.as(VariableDeclSyntax.self),
                  let binding = varDecl.bindings.first,
                  let identifier = binding.pattern.as(IdentifierPatternSyntax.self)?.identifier.text
            else {
                return nil
            }

            // Check for LocalizableString or LocalizableInt attributes
            let hasLocalizedWrapper = varDecl.attributes.contains { attribute in
                guard let attr = attribute.as(AttributeSyntax.self) else { return false }
                let attrName = attr.attributeName.description.trimmingCharacters(in: .whitespaces)
                return Self.knownLocalizedPropertyNames.contains(attrName)
            }

            guard hasLocalizedWrapper else { return nil }

            return (name: identifier, id: "\(identifier).localizationId")
        }

        // Generate the propertyNames function
        var pairs = properties.map { "_\($0.id): \"\($0.name)\"" }.joined(separator: ", ")
        if pairs.isEmpty {
            pairs = ":"
        }
        let functionDecl = try FunctionDeclSyntax(
            """
            public func propertyNames() -> [LocalizableId: String] {
                [\(raw: pairs)]
            }
            """
        )

        return [DeclSyntax(functionDecl)]
    }

    // MARK: Peer Macro Protocol

    public static func expansion(
        of node: AttributeSyntax,
        providingPeersOf declaration: some DeclSyntaxProtocol,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        guard node.attributeName.description.trimmingCharacters(in: .whitespaces) == "ViewModel" else {
            return []
        }

        guard let structDecl = declaration.as(StructDeclSyntax.self) else {
            throw ViewModelMacroError.onlyStructs
        }

        let viewModelName = structDecl.name.text

        let options: Set<ViewModelOptions> = if let argumentList = node.arguments?.as(LabeledExprListSyntax.self),
                                                let optionsElement = argumentList.first(where: { $0.label?.text == "options" }),
                                                let arrayExpr = optionsElement.expression.as(ArrayExprSyntax.self) {
            Set(arrayExpr.elements.map(\.expression)
                .compactMap { $0.as(MemberAccessExprSyntax.self)?.declName }
                .map(\.baseName.text)
                .compactMap { ViewModelOptions(rawValue: $0) })
        } else {
            []
        }

        if options.contains(.clientHostedFactory) {
            let requestClass = try ClassDeclSyntax(
                """
                public final class \(raw: viewModelName)Request: ViewModelRequest {
                    public let responseBody: \(raw: viewModelName)?
                    public init(
                        query: EmptyQuery?,
                        fragment: EmptyFragment? = nil,
                        requestBody: EmptyBody? = nil,
                        responseBody: \(raw: viewModelName)?
                    ) {
                        self.responseBody = responseBody
                    }
                }
                """
            )
            return [DeclSyntax(requestClass)]
        }

        return []
    }
}

private extension StructDeclSyntax {
    func conformsTo(_ protocolName: String) -> Bool {
        inheritanceClause?.inheritedTypes.contains { inheritedType in
            if let identifierType = inheritedType.type.as(IdentifierTypeSyntax.self) {
                identifierType.name.text == protocolName
            } else {
                false
            }
        } ?? false
    }
}
